{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

(builder) store_ref_new(builder b, cell c) inline asm(c b) "STREF";
forall X -> (tuple, ()) cons_new(tuple tail, X head) inline asm(head tail) "CONS";

(builder, ()) change_char(builder middle_result, int char, int shift) inline {
  int new_char = 0;
  if((65 <= char) & (char <= 90)) {
    new_char = ((65 <= (char + shift)) & ((char + shift) <= 90)) ? char + shift : char + shift - 26;
  }
  elseif((97 <= char) & (char <= 122)) {
    new_char = ((97 <= (char + shift)) & ((char + shift) <= 122)) ? char + shift : char + shift - 26;
  }
  else {
    new_char = char;
  }
  
  return (middle_result.store_uint(new_char, 8), ());
}

(builder) make_each_ref(slice stex, int shift) inline {
  builder middle_result = begin_cell();
  repeat(stex.slice_bits() / 8) {
    middle_result~change_char(stex~load_uint(8), shift);
  }

  return middle_result;
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
  shift = shift % 26;
  slice stex = text.begin_parse();
  tuple t_result = empty_tuple();
  t_result~cons_new(stex.make_each_ref(shift));

  int i = 0;
  repeat(stex.slice_depth()) {
    stex = stex.preload_ref().begin_parse();
    t_result~cons_new(stex.make_each_ref(shift));
    i += 1;
  }
  
  builder last = t_result~list_next();
  repeat(i) {
    last = t_result~list_next().store_ref_new(last.end_cell());
  }

  return last.end_cell();
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
  return caesar_cipher_encrypt(26 - shift, text);
}